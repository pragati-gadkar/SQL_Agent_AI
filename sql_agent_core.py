"""
SQL AI Agent - Core Logic

This module contains the core SQL agent functionality that can be used
by both CLI and Streamlit interfaces.
"""

import os
from typing import TypedDict, List, Any, Optional, Dict
from sqlalchemy import create_engine, inspect, text
from langchain_google_genai import ChatGoogleGenerativeAI
from langgraph.graph import StateGraph, START, END
from langchain_core.messages import HumanMessage, SystemMessage
import pandas as pd
from dotenv import load_dotenv

class SQLState(TypedDict):
    question: str          # User's natural language question
    schema: str            # The table names and columns (Agent reads this first)
    sql_query: str         # The SQL generated by the LLM
    query_results: Any     # The data returned from the DB
    error_log: str         # If SQL fails, the error message goes here
    iterations: int        # To prevent infinite loops during retries
    final_response: str    # LLM's friendly response
    validation_status: str # "pending", "valid", or "invalid"
    validation_retries: int # Track validation retry attempts
    validated_response: str # Final validated response

class SQLAIAgent:
    """SQL AI Agent for natural language to SQL query conversion and execution"""
    
    def __init__(self):
        """Initialize the SQL AI Agent with environment variables"""
        load_dotenv()
        
        # Load API key
        self.api_key = os.getenv('GOOGLE_API_KEY')
        if not self.api_key:
            raise ValueError("GOOGLE_API_KEY not found in .env file. Please add your API key.")
        
        # Load MySQL credentials
        self.mysql_user = os.getenv('MYSQL_USER', 'root')
        self.mysql_password = os.getenv('MYSQL_PASSWORD')
        self.mysql_host = os.getenv('MYSQL_HOST', 'localhost')
        self.mysql_port = os.getenv('MYSQL_PORT', '3306')
        self.mysql_database = os.getenv('MYSQL_DATABASE', 'sales')
        
        if not self.mysql_password:
            raise ValueError("MYSQL_PASSWORD not found in .env file. Please add your MySQL password.")
        
        # Initialize LLM
        self.llm = ChatGoogleGenerativeAI(model='gemini-1.5-flash', google_api_key=self.api_key)
        
        # Create database connection
        connection_string = f"mysql+pymysql://{self.mysql_user}:{self.mysql_password}@{self.mysql_host}:{self.mysql_port}/{self.mysql_database}"
        self.engine = create_engine(connection_string)
        
        # Build workflow
        self.app = self._build_workflow()
    
    def get_connection_info(self) -> Dict[str, str]:
        """Get MySQL connection information"""
        return {
            'host': self.mysql_host,
            'port': self.mysql_port,
            'database': self.mysql_database,
            'user': self.mysql_user
        }
    
    def test_connection(self) -> bool:
        """Test MySQL database connection"""
        try:
            with self.engine.connect() as conn:
                conn.execute(text("SELECT 1"))
            return True
        except Exception as e:
            print(f"Connection error: {e}")
            return False
    
    def generate_schema_image(self, output_path: str = "schema_diagram.png") -> str:
        """Generate a visual database schema diagram as an image using Pillow"""
        from PIL import Image, ImageDraw, ImageFont
        import os
        
        inspector = inspect(self.engine)
        
        # Configuration
        TABLE_WIDTH = 300
        COLUMN_HEIGHT = 30
        TABLE_SPACING = 100
        HEADER_HEIGHT = 40
        PADDING = 10
        
        # Colors
        BG_COLOR = (255, 255, 255)
        TABLE_HEADER_COLOR = (100, 149, 237)  # Cornflower blue
        TABLE_BG_COLOR = (240, 248, 255)  # Alice blue
        BORDER_COLOR = (70, 130, 180)  # Steel blue
        TEXT_COLOR = (0, 0, 0)
        PK_COLOR = (255, 215, 0)  # Gold
        FK_COLOR = (144, 238, 144)  # Light green
        
        # Collect table information
        tables = []
        
        for table_name in inspector.get_table_names():
            pk_constraint = inspector.get_pk_constraint(table_name)
            pk_columns = pk_constraint.get('constrained_columns', []) if pk_constraint else []
            
            fks = inspector.get_foreign_keys(table_name)
            fk_columns = []
            for fk in fks:
                fk_columns.extend(fk['constrained_columns'])
            
            columns = []
            for col in inspector.get_columns(table_name):
                col_info = {
                    'name': col['name'],
                    'type': str(col['type']),
                    'is_pk': col['name'] in pk_columns,
                    'is_fk': col['name'] in fk_columns
                }
                columns.append(col_info)
            
            tables.append({
                'name': table_name,
                'columns': columns
            })
        
        # Calculate image dimensions
        tables_per_row = 2
        num_rows = (len(tables) + tables_per_row - 1) // tables_per_row
        
        img_width = (TABLE_WIDTH + TABLE_SPACING) * tables_per_row + PADDING * 2
        img_height = sum([
            HEADER_HEIGHT + len(t['columns']) * COLUMN_HEIGHT + TABLE_SPACING 
            for t in tables
        ]) // tables_per_row + PADDING * 2 + 100
        
        # Create image
        img = Image.new('RGB', (img_width, img_height), BG_COLOR)
        draw = ImageDraw.Draw(img)
        
        # Try to use a nice font, fallback to default
        try:
            font_title = ImageFont.truetype("arial.ttf", 16)
            font_text = ImageFont.truetype("arial.ttf", 12)
        except:
            font_title = ImageFont.load_default()
            font_text = ImageFont.load_default()
        
        # Draw tables
        x_offset = PADDING
        y_offset = PADDING
        
        for idx, table in enumerate(tables):
            # Calculate position
            if idx > 0 and idx % tables_per_row == 0:
                x_offset = PADDING
                y_offset += max([len(t['columns']) for t in tables[idx-tables_per_row:idx]]) * COLUMN_HEIGHT + HEADER_HEIGHT + TABLE_SPACING
            
            # Draw table header
            header_rect = [x_offset, y_offset, x_offset + TABLE_WIDTH, y_offset + HEADER_HEIGHT]
            draw.rectangle(header_rect, fill=TABLE_HEADER_COLOR, outline=BORDER_COLOR, width=2)
            
            # Draw table name
            text_bbox = draw.textbbox((0, 0), table['name'], font=font_title)
            text_width = text_bbox[2] - text_bbox[0]
            text_x = x_offset + (TABLE_WIDTH - text_width) // 2
            draw.text((text_x, y_offset + 10), table['name'], fill=(255, 255, 255), font=font_title)
            
            # Draw columns
            col_y = y_offset + HEADER_HEIGHT
            for col in table['columns']:
                # Determine background color
                if col['is_pk']:
                    bg_color = PK_COLOR
                elif col['is_fk']:
                    bg_color = FK_COLOR
                else:
                    bg_color = TABLE_BG_COLOR
                
                # Draw column background
                col_rect = [x_offset, col_y, x_offset + TABLE_WIDTH, col_y + COLUMN_HEIGHT]
                draw.rectangle(col_rect, fill=bg_color, outline=BORDER_COLOR)
                
                # Draw column text
                markers = []
                if col['is_pk']:
                    markers.append('PK')
                if col['is_fk']:
                    markers.append('FK')
                marker_text = f" [{', '.join(markers)}]" if markers else ""
                
                col_text = f"{col['name']}: {col['type']}{marker_text}"
                draw.text((x_offset + 5, col_y + 8), col_text, fill=TEXT_COLOR, font=font_text)
                
                col_y += COLUMN_HEIGHT
            
            # Move to next column position
            x_offset += TABLE_WIDTH + TABLE_SPACING
        
        # Save image
        full_path = os.path.join(os.path.dirname(__file__), output_path)
        img.save(full_path)
        return full_path
    
    def get_schema_info(self) -> str:
        """Get enhanced database schema information with types and constraints"""
        inspector = inspect(self.engine)
        schema_info = "Database Schema:\n\n"
        
        for table_name in inspector.get_table_names():
            schema_info += f"Table: {table_name}\n"
            
            # Get columns with types and constraints
            for col in inspector.get_columns(table_name):
                col_type = str(col['type'])
                nullable = "" if col['nullable'] else ", NOT NULL"
                default = f", DEFAULT {col.get('default', '')}" if col.get('default') else ""
                schema_info += f"  - {col['name']}: {col_type}{nullable}{default}\n"
            
            # Get primary keys
            pk = inspector.get_pk_constraint(table_name)
            if pk and pk.get('constrained_columns'):
                schema_info += f"  PRIMARY KEY: ({', '.join(pk['constrained_columns'])})\n"
            
            # Get foreign keys
            fks = inspector.get_foreign_keys(table_name)
            for fk in fks:
                constrained = ', '.join(fk['constrained_columns'])
                referred_table = fk['referred_table']
                referred_cols = ', '.join(fk['referred_columns'])
                schema_info += f"  FOREIGN KEY: ({constrained}) -> {referred_table}({referred_cols})\n"
            
            schema_info += "\n"
        
        return schema_info
    
    def _schema_node(self, state: SQLState) -> SQLState:
        """Fetch database schema"""
        schema_info = self.get_schema_info()
        return {"schema": schema_info}
    
    def _sql_gen_node(self, state: SQLState) -> SQLState:
        """Generate SQL query using LLM"""
        question = state['question']
        schema = state['schema']
        error = state.get('error_log', "")
        
        if not error:
            prompt = f"Based on this schema:\n{schema}\n\nWrite a MySQL query for: {question}. Output ONLY the SQL."
        else:
            prompt = f"Your previous SQL was wrong.\nError: {error}\n\nSchema:\n{schema}\nFix the SQL for: {question}. Output ONLY the SQL."
        
        response = self.llm.invoke([HumanMessage(content=prompt)])
        clean_sql = response.content.replace("```sql", "").replace("```", "").strip()
        
        return {"sql_query": clean_sql}
    
    def _execute_node(self, state: SQLState) -> SQLState:
        """Execute SQL query"""
        sql = state['sql_query']
        
        try:
            with self.engine.connect() as conn:
                results = pd.read_sql(text(sql), conn)
            
            return {
                "query_results": results.to_dict(),
                "error_log": "",
                "iterations": state['iterations'] + 1
            }
        except Exception as e:
            return {
                "error_log": str(e),
                "iterations": state['iterations'] + 1
            }
    
    def _should_continue(self, state: SQLState):
        """Determine if we should retry or respond"""
        if state['error_log'] and state['iterations'] < 3:
            return "retry"
        return "respond"
    
    def _responder_node(self, state: SQLState) -> SQLState:
        """Generate friendly response"""
        question = state['question']
        results = state['query_results']
        
        prompt = f"""
        The user asked: {question}
        The database returned these results: {results}
        
        Provide a friendly, concise answer to the user.
        """
        
        response = self.llm.invoke([HumanMessage(content=prompt)])
        return {
            "final_response": response.content,
            "validation_status": "pending"
        }
    
    def _validator_node(self, state: SQLState) -> SQLState:
        """Validate that the response accurately reflects the query results"""
        question = state['question']
        results = state['query_results']
        response = state['final_response']
        
        validation_prompt = f"""
        You are a data accuracy validator. Your job is to verify if the response accurately reflects the query results.
        
        USER QUESTION: {question}
        QUERY RESULTS: {results}
        LLM RESPONSE: {response}
        
        Analyze if the response:
        1. Accurately reflects the data in the query results
        2. Answers the user's question correctly
        3. Contains no hallucinated or incorrect information
        4. Properly handles empty results if applicable
        
        Respond ONLY with one of these:
        - "VALID" - if the response is accurate and correct
        - "INVALID: [reason]" - if there are issues, explain what's wrong
        """
        
        validation = self.llm.invoke([HumanMessage(content=validation_prompt)])
        validation_result = validation.content.strip()
        
        if validation_result.startswith("VALID"):
            return {
                "validation_status": "valid",
                "validated_response": response
            }
        else:
            # Response needs regeneration
            retry_count = state.get('validation_retries', 0) + 1
            
            # If we've retried too many times, accept the current response
            if retry_count >= 2:
                return {
                    "validation_status": "valid",
                    "validated_response": response,
                    "validation_retries": retry_count
                }
            
            # Regenerate with feedback
            regenerate_prompt = f"""
            Your previous response had accuracy issues:
            {validation_result}
            
            USER QUESTION: {question}
            QUERY RESULTS: {results}
            
            Provide a NEW, accurate response that addresses the validation issues.
            """
            
            new_response = self.llm.invoke([HumanMessage(content=regenerate_prompt)])
            return {
                "final_response": new_response.content,
                "validation_status": "pending",
                "validation_retries": retry_count
            }
    
    def _should_validate(self, state: SQLState):
        """Determine if we should validate again or finish"""
        if state['validation_status'] == 'pending':
            return "validate"
        return "finish"
    
    def _build_workflow(self):
        """Build the LangGraph workflow"""
        workflow = StateGraph(SQLState)
        
        # Add nodes
        workflow.add_node("fetch_schema", self._schema_node)
        workflow.add_node("generate_sql", self._sql_gen_node)
        workflow.add_node("execute_sql", self._execute_node)
        workflow.add_node("responder", self._responder_node)
        workflow.add_node("validator", self._validator_node)
        
        # Add edges
        workflow.add_edge(START, "fetch_schema")
        workflow.add_edge("fetch_schema", "generate_sql")
        workflow.add_edge("generate_sql", "execute_sql")
        
        # Add conditional edges
        workflow.add_conditional_edges(
            "execute_sql",
            self._should_continue,
            {
                "retry": "generate_sql",
                "respond": "responder"
            }
        )
        
        workflow.add_conditional_edges(
            "validator",
            self._should_validate,
            {
                "validate": "validator",
                "finish": END
            }
        )
        
        workflow.add_edge("responder", "validator")
        
        return workflow.compile()
    
    def ask(self, question: str) -> Dict[str, Any]:
        """
        Ask a question about the database
        
        Args:
            question: Natural language question
            
        Returns:
            Dictionary containing:
                - question: Original question
                - sql_query: Generated SQL query
                - query_results: Query results as dict
                - final_response: Natural language response
                - error_log: Any errors encountered
        """
        inputs = {
            "question": question,
            "iterations": 0,
            "validation_retries": 0
        }
        
        result = self.app.invoke(inputs)
        
        return {
            "question": result.get('question', ''),
            "sql_query": result.get('sql_query', ''),
            "query_results": result.get('query_results', {}),
            "final_response": result.get('validated_response', result.get('final_response', '')),
            "error_log": result.get('error_log', ''),
            "validation_status": result.get('validation_status', '')
        }


if __name__ == "__main__":
    # CLI usage
    agent = SQLAIAgent()
    
    print(f"[SUCCESS] Connected to MySQL database '{agent.mysql_database}' on {agent.mysql_host}:{agent.mysql_port}")
    
    question = "Show me all tables in the database"
    print(f"\nQuestion: {question}")
    
    result = agent.ask(question)
    
    print(f"\nGenerated SQL: {result['sql_query']}")
    print(f"\nAnswer: {result['final_response']}")
